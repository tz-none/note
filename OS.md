# 操作系统

- [操作系统](#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f)
  - [1.导论](#1%e5%af%bc%e8%ae%ba)
    - [1.1计算机系统组织](#11%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87)
    - [1.2计算机系统操作](#12%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e6%93%8d%e4%bd%9c)
    - [1.3I/O结构](#13io%e7%bb%93%e6%9e%84)
    - [1.4多道程序设计](#14%e5%a4%9a%e9%81%93%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1)
    - [1.5系统分类](#15%e7%b3%bb%e7%bb%9f%e5%88%86%e7%b1%bb)
    - [1.6双重模式操作](#16%e5%8f%8c%e9%87%8d%e6%a8%a1%e5%bc%8f%e6%93%8d%e4%bd%9c)
  - [2.操作系统结构](#2%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84)
    - [2.1操作系统服务](#21%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%9c%8d%e5%8a%a1)
    - [2.2系统调用](#22%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8)
    - [2.3操作系统的设计和实现](#23%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e5%92%8c%e5%ae%9e%e7%8e%b0)
    - [2.4操作系统结构](#24%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84)
  - [3.进程](#3%e8%bf%9b%e7%a8%8b)
    - [3.1进程概念](#31%e8%bf%9b%e7%a8%8b%e6%a6%82%e5%bf%b5)
    - [3.2进程调度](#32%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6)
    - [3.3进程操作](#33%e8%bf%9b%e7%a8%8b%e6%93%8d%e4%bd%9c)
    - [3.4进程间通信](#34%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1)
  - [4.线程](#4%e7%ba%bf%e7%a8%8b)
  - [5.CPU调度](#5cpu%e8%b0%83%e5%ba%a6)
    - [5.1CPU调度时机](#51cpu%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba)
    - [5.2调度准则](#52%e8%b0%83%e5%ba%a6%e5%87%86%e5%88%99)
    - [5.3调度算法](#53%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95)
  - [6.进程同步](#6%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5)
    - [6.1软件解决方案——Peterson算法](#61%e8%bd%af%e4%bb%b6%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88peterson%e7%ae%97%e6%b3%95)
    - [6.2硬件解决方案](#62%e7%a1%ac%e4%bb%b6%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
    - [6.3信号量(Semaphore)](#63%e4%bf%a1%e5%8f%b7%e9%87%8fsemaphore)
  - [7.死锁](#7%e6%ad%bb%e9%94%81)
    - [7.1死锁预防](#71%e6%ad%bb%e9%94%81%e9%a2%84%e9%98%b2)
    - [7.2死锁避免](#72%e6%ad%bb%e9%94%81%e9%81%bf%e5%85%8d)
    - [7.3死锁检测](#73%e6%ad%bb%e9%94%81%e6%a3%80%e6%b5%8b)
    - [7.4死锁恢复](#74%e6%ad%bb%e9%94%81%e6%81%a2%e5%a4%8d)
  - [8.内存管理(实存)](#8%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%ae%9e%e5%ad%98)
    - [8.1连续内存分配(作业进入主存时分配连续)](#81%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%bd%9c%e4%b8%9a%e8%bf%9b%e5%85%a5%e4%b8%bb%e5%ad%98%e6%97%b6%e5%88%86%e9%85%8d%e8%bf%9e%e7%bb%ad)
    - [8.2分页存储管理](#82%e5%88%86%e9%a1%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86)
    - [8.3分段存储管理](#83%e5%88%86%e6%ae%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86)
  - [9.虚存管理](#9%e8%99%9a%e5%ad%98%e7%ae%a1%e7%90%86)
    - [9.1按需分页](#91%e6%8c%89%e9%9c%80%e5%88%86%e9%a1%b5)
    - [9.2页置换](#92%e9%a1%b5%e7%bd%ae%e6%8d%a2)
    - [9.3页框分配](#93%e9%a1%b5%e6%a1%86%e5%88%86%e9%85%8d)
    - [9.4抖动](#94%e6%8a%96%e5%8a%a8)
  - [10.文件系统](#10%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f)
    - [10.1访问方式](#101%e8%ae%bf%e9%97%ae%e6%96%b9%e5%bc%8f)
    - [10.2目录结构](#102%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84)
    - [10.3保护](#103%e4%bf%9d%e6%8a%a4)
    - [10.4文件组织](#104%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87)
    - [10.5分配](#105%e5%88%86%e9%85%8d)
    - [10.5外存空间管理](#105%e5%a4%96%e5%ad%98%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86)
    - [10.6效率和性能](#106%e6%95%88%e7%8e%87%e5%92%8c%e6%80%a7%e8%83%bd)
  - [11.磁盘管理](#11%e7%a3%81%e7%9b%98%e7%ae%a1%e7%90%86)
    - [11.1磁盘调度](#111%e7%a3%81%e7%9b%98%e8%b0%83%e5%ba%a6)
    - [11.2磁盘管理](#112%e7%a3%81%e7%9b%98%e7%ae%a1%e7%90%86)
  - [12.I/O输入系统](#12io%e8%be%93%e5%85%a5%e7%b3%bb%e7%bb%9f)

## 1.导论

> 操作系统：用于管理和控制系统资源，合理组织计算机工作流程，方便用户使用计算机的程序集。

### 1.1计算机系统组织

现代通用计算机系统有一个或多个CPU和若干设备控制器通过共同的总线相连而成，该总线提供了对主存的访问。
每一个类型的设备有各自的控制器。

### 1.2计算机系统操作

> I/O设备和CPU同时执行
>
> 每个设备控制器负责一个特定的设备类型
>
> 每个设备控制器都有一个本地缓冲区
>
> CPU将数据从主存移动到本地缓冲区
>
> I/O是从设备到控制器的本地缓冲区
>
> 设备控制器通过中断通知CPU它已经完成了它的操作

中断源：能够产生中断的资源。
中断：CPU暂停当前处理程序，转去执行中断处理程序的过程。
中断向量：包含所有中断处理程序的地址。
中断处理过程：
1.保存现场；
2.转去执行中断处理程序；
3.恢复现场。
> 中断分为硬件和软件中断，硬件可随时通过系统总线向CPU发出信号，触发中断。软件通过执行特别的操作如系统调用，触发中断。

### 1.3I/O结构

I/O开始后，控制返回程序的方式：
1.同步：在I/O完成时。
2.异步：不等待I/O完成。

直接内存访问(direct memory access)：用于能够以接近内存速度传输信息的高速I/O设备，设备控制器直接将数据块从缓冲存储器传输到主存储器，不需要CPU的干预，每个块只产生一个中断，而不是每个字节产生一个中断。

### 1.4多道程序设计

> 操作系统同时将多个任务保存在内存中。
>
> 作业调度(高级调度)：按照一定算法，从外存中选择满足的作业入内存(宏观)。
>
> CPU调度(低级调度)：按照一定算法，从内存选择满足条件的作业分配CPU。

作业状态
![作业状态](/image/os/job_state.png)

单道程序设计与多道程序设计作业对比
![单道与多道程序设计](image/os/single_multiprogrammed.png)
> 优点：提高CPU利用率、提高内存和I/O设备利用率、提高系统吞吐量。
>
> 特点：多道、无序、调度。

### 1.5系统分类

**实时系统**：严格的时间要求，用于专门用途的系统。中断处理机制更强。其主要特征是：对实时信息分析处理速度要比进入系统快、要求安全可靠、资源利用率低。
> 硬实时：数据存在内存或ROM(只读存储器)
>
> 软实时：适用于多媒体、虚拟现实等领域。

**批处理系统**：操作员把用户提交的作业分类，把一批作业编成一个作业执行序列，由专门编制的监督程序自动依次处理。其主要特征是：用户脱机使用计算机、成批处理、多道程序运行。

**分时系统**：把处理机的运行时间分成很短的时间片，按时间片轮转的方式，把处理机分配给各进程使用。其主要特征是：交互性、多用户同时性、独立性。

### 1.6双重模式操作

两种独立的操作模式：用户模式和内核模式。

双模式操作提供了保护操作系统和用户程序不受错误用户程序影响的手段。

在计算机硬件中增加一个称为模式位的位表示当前模式。通过模式位可以做到区分系统何时运行用户代码或内核代码。

系统调用时模式会更改为内核模式执行，执行完后从调用中返回并将其重置为用户模式

特权指令：能引起损害的，只能由操作系统执行的**机器指令**。

## 2.操作系统结构

### 2.1操作系统服务

用户界面：命令界面(commond-line interface, CLI)、图形化界面(graphical user interface, GUI)、批界面(Batch)

程序执行、I/O操作、文件系统操作错误检测、资源分配、统计

通信：共享内存、消息传递

保护和安全：确保对系统资源的所有访问都受到控制(保护)、保护I/O设备不受非法访问(安全)

> 操作系统功能主要分为5个方面：存储管理、、处理机管理、设备管理、文件管理和用户接口。

### 2.2系统调用

> 系统调用：操作系统提供的编程接口，主要通过高级应用程序接口(API)访问，而不是直接使用系统调用。

系统调用实现：
![处理一个调用open()系统调用的用户应用程序](image/os/system_call_implementation.png)
> 每个系统调用都有一个相关联的数字
> 查找系统调用表来定位预期的函数
> 调用预期的函数并返回状态和值

向操作系统传参的方法：
1.通过寄存器传参
2.将参数存在内存中的块和表中，并将块和表的地址放入寄存器来传递
3.通过堆栈

### 2.3操作系统的设计和实现

> 通过定义系统的目标和规范来实现。在最高层，受硬件选择、系统类型选择的影响。

需求可分为两个基本类：用户目标和系统目标。
1.用户目标：使用方便、容易学习、可靠、安全、快捷
2.系统目标：易于设计、实现和维护，灵活、可靠、无错误、高效

策略:做什么
机制:如何做

### 2.4操作系统结构

简单结构
分层结构
微内核
模块化
虚拟机

## 3.进程

### 3.1进程概念

> 进程：一个有独立功能的程序，关于某个数据集合的一次运行过程。
>
> 进程包括：程序计数器、寄存器、堆栈段、数据段、文本段还有堆。
>
> 进程状态：
> ![进程状态的转换](image/os/process_state.png)
> 新的(new)：进程正在被创建
>
> 就绪(ready)：进程等待分配处理器
>
> 运行(running)：指令正在被运行
>
> 等待(waiting)：等待某个事件的发生(如I/O完成或收到信号)
>
> 终止(terminated)：进程完成执行

- 进程与程序的区别：
  1. 动态与静态
  2. 生命周期
  3. 进程 = 程序 + 数据 + PCB
  4. 一个程序可以对应多个进程
  5. 一个进程可以包含多个程序
  6. 没有进程的程序不能被运行(进程是被CPU调度的基本单位)

**程序控制块(process control block, PCB)**：有结构的主存区，用于保存进程所有的相关信息；随着对应进程的创建而创建，对应进程的消亡而撤销。(系统通过PCB里的相关信息感知进程，**PCB是进程存在的唯一标志**)

- PCB存储的信息：
  1. 进程状态
  2. 程序计数器
  3. CPU寄存器
  4. CPU调度信息
  5. 内存管理信息
  6. 记账信息
  7. I/O状态信息

### 3.2进程调度

> 作业队列：系统中的所有进程集合
>
> 就绪队列：驻留在内存中就绪的、等待被运行的进程的集合
>
> 设备队列：等待I/O设备的进程的集合
>
> 进程在各种队列中迁移

| 长期调度                       | 短期调度                        |
| ------------------------------ | ------------------------------- |
| 选择应该将哪些进程放入就绪队列 | 选择接下来执行哪个进程并分配CPU |
| 从外存到内存                   | 从就绪队列中                    |
| 频率较低                       | 更频繁                          |

**中期调度**：核心思想是能将进程从内存(或从CPU竞争)总移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案成为交换。

绝大多数进程可分为：I/O型进程(I/O-bound)、CPU型进程(CPU-bound)

上下文切换(Context Switch)：当进程切换到另一个进程时，需要保存当前进程状态并另一个进程的状态。上下文切换的时间是开销，时间依赖于硬件支持。

### 3.3进程操作

**进程创建**过程：申请PCB、分配资源、填写PCB、入Ready队列。

- 三种资源共享方式
  1. 父进程和子进程共享所有资源
  2. 子进程共享父进程资源的一部分
  3. 父、子进程不共享资源
- 执行
  1. 父、子进程并发执行
  2. 父进程等待子进程执行完
- 地址空间
  1. 子进程是父进程的副本
  2. 子进程装入另外一个新程序

> 父进程创建子进程，每个新进程可以在创建其他进程，从而形成了进程树。

**进程终止**：当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止。这时进程可以返回状态值到父进程(用过系统调用wait())。进程资源有操作系统重新分配。
> 父进程可以终止子进程(abort)。父进程终止子进程的原因有很多，如：子节点已经超出了已分配的资源、不再需要分配给子进程的任务、父结点退出，父进程终止，那么操作系统不允许子进程在父进程终止时继续(级联终止)

### 3.4进程间通信

> 独立进程：一个进程不能影响其他进程或不被其他进程影响，那么该进程是独立的。
>
> 协同进程：一个进程能能影响其他进程或被其他进程影响，那么该进程是协同的。
>
> 协同进程的优点：信息共享、提高运算速度、模块化、方便。

进程间通信机制(interprocess communication, IPC)，进程间通信两大类：信息传递(message passing)、共享内存(share memory)

**生产者-消费者问题**
条件：由生产者和消费者共享的缓冲区，生产者产生信息，消费者消费

| 无限缓冲                                             | 有限缓冲                                               |
| ---------------------------------------------------- | ------------------------------------------------------ |
| 消费者可能不得不等待新的项，但生产者总是可以产生新项 | 缓冲为空时，消费者必须等待；缓冲为满时，生产者必须等待 |

> 有限缓冲下
>
> 生产者进程
>
> ```c
> while(true) {
>   /*produce an item in nextProduced*/
>   while(((in+1)%BUFFER_SIZE) == out);
>   buffer[in] = nextProduced;
>   in = (in+1)%BUFFER_SIZE;
> }
> ```
>
> 消费者进程
>
> ```c
> while(true) {
>   while(in == out);
>   nextCosumed = buffer[out];
>   out = (out+1)%BUFFER_SIZE;
>   /*consumed the item in nextConsumed*/
> }
> ```
>
> 这样的解决方式存在缺陷

信息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。

- 信息传递提供两种操作：
  1. send()
     - 固定大小：系统及实现简单，编程任务困难。
     - 可变长大小：更复杂的系统级实现，但编程任务变得简单。
  2. receive()

如果进程P和Q需要通信，那么他们必须彼此相互发送消息和接受消息，他们之间必须要有通信线路。下面是一些逻辑实现通信线路和send()/receive()操作的方法。

- 直接通信
  - 属性
    - 线路是自动建立的
    - 一个链接仅与一对正在通信的进程相关联
    - 每一对之间存在一个线路
    - 线路可能是单向的，但通常是双向的
  - 原语操作定义
    - send(P, message)：发送消息到P进程
    - receive(Q, messafg)：接受来自进程Q的消息
- 间接通信
  - 属性
    - 仅当进程共享邮箱时才建立通信线路
    - 一个链接可以与许多进程相关联
    - 两个进程可以有多个不同的线路，每个线路对应一个邮箱
    - 线路可以使单向的，也可以是双向的
  - 操作
    - 创建新邮箱
    - 通过邮箱发送和接受消息
    - 删除邮箱
  - 原语操作定义
    - send(A, message)：发送消息到邮箱A
    - receive(A, messafg)：接受来自邮箱A的消息
- 同步与异步
  - 阻塞send：发送进程阻塞，知道消息被接受进程或邮箱所接收
  - 非阻塞send：发送进程发送消息并再继续操作
  - 阻塞receive：接受者阻塞，直到有消息可用
  - 非阻塞receive：接受者收到一个有效消息或空消息
- 缓冲
  - 零容量
  - 有限容量
  - 无限容量

## 4.线程

> 线程是可以被独立调度的基本单位，它有线程ID、程序计数器、寄存器集合和栈组成，与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源。
>
> 优点：响应度高、资源共享、经济、可用于多处理器。

- 多线程模型：
  1. 多对一模型：将许多用户级线程映射到一个内核级线程，任一时刻只能有一个线程访问内核，故不能用于多处理。
  2. 一对一模型：将每个用户线程映射到一个内核线程，可用于多处理器，但是每创建一个用户线程就需要创建一个相应的内核线程，所以需要限制数量。
  3. 多对多模型：可用于多处理器。

- 线程和进程之间有如下关系：
  1. 一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。
  2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
  3. 处理机分给线程，即真正在处理机上运行的是线程。
  4. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

## 5.CPU调度

### 5.1CPU调度时机

1. 进程从running到waiting
2. 时间片到了(从running到ready)
3. 就绪队列来进程，会引起一次新调度
4. 进程终止

> 1,4主动(非抢占的)；2,3(被动)抢占的

调度器(分派程序)功能：上下文切换、切换到用户态和跳转。

### 5.2调度准则

1. CPU使用率
2. 吞吐量：单位时间内完成进程的数量
3. 周转时间：从进程提交到进程完成的时间段称为周转时间
4. 等待时间：在就绪队列中等待所花费的时间
5. 响应时间：从提交请求到第一响应的时间

> 需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。

### 5.3调度算法

- 先到先服务调度(FCFS)
  - 优点：公平；缺点：平均等待时间长

- 最短作业优先调度(SJF)
  - 思想：当CPU空闲时，会赋给最短CPU区间的进程
  - 困难：如何知道下一个CPU区间的长度
  - 解决办法：使用指数平均法
  - 变化：抢占SJF调度(最短剩余时间调度)

- 优先级调度
  - 分类：抢占和非抢占
  - 问题：饥饿

- 轮转法调度(RR)
  - 思想：定义一个较小时间单元，称为时间片，将就绪队列作为循环队列。CPU调度程序循环就绪队列
  - 特点：响应时间短，周转时间长
  - 影响因素：时间片(时间片趋近无穷时就是FCFS)，终端数

- 多级队列调度
  - 思想：将就绪队列分成多个独立队列。
  - 举例：一个常用的划分方法是前台(交互)进程和后台(批处理)进程，每个队列都有一定的CPU时间。例如，前台可以有80%的CPU时间进行RR调度，后台队列可以有20%的CPU时间进行FCFS调度

- 多级反馈队列调度
  - 思想：
    1. 分成多个优先级，有不同优先级
    2. 所有进程入最高级队列
    3. 最先调度高优先级队列
    4. 当前被调度进程在时间内完成则出队，未完成就降级
    5. 当高优先级队列为空，转下一级队列调度

> 多级反馈队列调度是一个综合型调度算法，包含了前面5中调度算法。

## 6.进程同步

> 进程间的同步：异步环境下一组并发进程因直接制约相互发送消息而进行相互合作、相互等待，使得各进程按照一定的速度执行的过程。
>
> 互斥使用共享变量或数据结构
>
> 临界资源(Critical Resource)：一次只能被一个进程使用，例如，慢速设备、共享变量和数据结构

使用临界资源的代码结构：进入区(Entry section)、**临界区(Critical section)**、结束区(Exit section)、剩余区(Remainder section)

- 临界使用准则：
  1. 空闲让进：多个进程要求进入空闲的临界区，一次仅让一个进程进入。
  2. 忙则等待：若已有进程进入临界区，则其他要求进入临界区的进程必须等待。
  3. 让权等待：如果进程需要等待，则需要让出CPU，避免出现忙等。
  4. 有限等待：进入临界区的进程在有限时间内退出，让其他进程及时进入临界区，即等待时间有限。

### 6.1软件解决方案——Peterson算法

```cpp
//pi
while(true) {
    flag[i] = true;
    turn = j;
    while(flag[j] && turn == j);
    //CRITICAL SECTION
    flag[i] = false;
    //REMAINDER SECTION
}
//没有解决忙等问题
```

### 6.2硬件解决方案

1.TS(Test And Set)

```cpp
bool TestAndSet(bool *target) {
    bool rv = *target;
    *target = true;
    return rv;
}

do{
    while(TestAndSet(&lock));
    //CRITICAL SECTION
    lock = false;
    //REMAINDER SECTION
}while(true);
```

2.Swap

```cpp
void Swap(bool *a, bool *b) {
    bool temp = *a;
    *a = *b;
    *b = temp;
}

do{
    key = true;
    while(key == true)
      Swap(&lock, &key);
    //CRITICAL SECTION
    lock = false;
    //REMAINDER SECTION
}while(true);
//同样存在忙等问题
```

### 6.3信号量(Semaphore)

定义：只能通过P、V操作(原语操作)修改其值的整形变量，成为信号量。

- 类型：
  1. 互斥信号量(初值为1)，也称为互斥锁。
  2. 计数信号量(一般信号量)
  3. 记录型信号量：每个信号量除了一个整数值以外，还有一个进程等待队列

信号量S在P、V操作中的物理意义：P(S)向系统申请S代表的临界资源，V(S)释放一个S代表的临界资源

```cpp
P(semaphore *S) {
    S->value--;
    if(S->value < 0) {
        //add this process to S->list;
        block();
    }
}

V(semaphore *S) {
    S->value--;
    if(S->value <= 0) {
        //remove a process P from S->list;
        wakeup(P);
    }
}
// |S->value|是等待进程数
```

- 经典同步问题
  1. 生产者-消费者问题
  2. 读者-写者问题
  3. 哲学家进餐问题

## 7.死锁

> 死锁：两个或两个以上由于竞争资源导致进程互为等待而无法推进，此时系统状态称为死锁。
>
> 死锁产生原因：资源相对不足、推进顺序不合理
>
> 死锁产生的必要条件：互斥、占有并等待、非抢占、循环等待
>
> 死锁处理方法：不允许出现、可恢复、假定不会出现

### 7.1死锁预防

- 思想：破坏四个必要条件之一
  1. 破坏占有并等待：一次性资源分配法(缺：浪费、系统道数降低)
  2. 破坏循环等待：有序资源使用法，给资源进行编号，按编号进行申请(缺：浪费，但比一次性资源分配法好)

### 7.2死锁避免

银行家算法：当用户申请一组资源时，系统必须确定这些资源的分配是否仍会使系统处于安全状态，如果是，就可分配资源；否则，进程必须等待直到某个其他进程释放足够资源为止。

前提：多实例、每个进程预先声明需要多少资源。

- 数据结构：
  - Available：资源向量(长度为m的向量，m为资源种类数)
  - Max：定义进程的最大需求(n * m矩阵，n表示进程数)
  - Allocation：定义每个进程已分配的资源(n * m矩阵，n表示进程数)
  - Need：定义每个进程还需要的资源数(n * m矩阵，n表示进程数)

> 注意：Need[i][j] = Max[i][j] - Allocation[i][j]

**安全性算法**：
1.设Work和Finish分别为长度为m和n的向量，Work=Available且对于i=0,1,...,n-1，Finish[i]=false。
2.查找这样的i满足Finish[i]=false且Need[i]<=Work[i]，若没有则跳转到第4步。
3.Work[i]+=Allocation[i];Finish[i]=true;返回第二步。
4.如果对于所有的i，Finish[i]=true，那么系统处于安全状态。
> 这个算法需要n * m^2数量级的操作确定系统状态是否安全

**资源请求算法**：
1.设Request[i]为Pi的请求向量，如果Request[i][j]=k，那么进程Pi需要资源类型Rj的实例数量为k。
2.如果Request[i]<=Need[i]，那么转到第3步。否则产生错误条件，因为进程Pi超过最大请求。
3.如果Request[i]<=Available，那么转到第4步；否则Pi必须等待，因为没有可用的资源。
4.假定系统可以分配给进程Pi所请求的资源，并按以下方式修改状态：
Available = Available - Request[i];
Allocation[i] = Allocation[i] + Request[i];
Need[i] = Need[i] - Request[i];
如果产生的资源分配状态是安全的这分配；否则进程Pi等待并恢复到原来资源分配状态。

### 7.3死锁检测

1. 等待图(单实例)
2. 检测算法(多实例，类似银行家算法)

### 7.4死锁恢复

1. 终止全部
2. 一次终止一个知道死锁解除

> 如何决定终止哪一个进程?

## 8.内存管理(实存)

> 逻辑地址：用户程序中的地址称为逻辑地址，也称为相对地址。
>
> 逻辑地址空间：有程序所生成的所有逻辑地址的集合。
>
> 物理地址：绝对地址。
>
> 物理地址空间：与逻辑地址相对应的所有物理地址的集合。
>
> 逻辑地址到物理地址的转换称为程序的重定位。
>
> 静态重定位：运行前完成转换(优：执行效率高，缺：不能移动)
>
> 动态重定位：运行前不重定位，运行中完成，需要使用基址寄存器、界限寄存器(优：可移动，缺：执行效率下降)

### 8.1连续内存分配(作业进入主存时分配连续)

1. 固定分区分配(分区数量固定，分区大小固定)
   - 缺：道数低、浪费(内碎片)
2. 可变分区分配(分区数量可变，分区大小可变)
   - 分配：从未分配表中找足够大的内存区域分配
   - 分配策略
     - 首次适应：未分配表按起始地址排序，找到第一个足够大的内存区域
     - 最佳适应：未分配表按内存区域从小到大排序，找到第一个足够大的内存区域
     - 最差适应：未分配表按内存区域从大到小排序，找到第一个足够大的内存区域
     - 分区回收：判断相邻分区是否分配，如没有则合并两个分区。

> 碎片：在分区法中，内存出现许多容量太小、无法被利用的小分区称作碎片。
>
> 解决办法：程序浮动/存储紧缩或允许物理地址空间不连续

### 8.2分页存储管理

- 思想：
  1. 物理地址按2^n等分成页框(架/帧)，从0开始编号
  2. 逻辑地址按页框大小等分成页，从0开始编号
  3. 逻辑地址表示(p, d)，p表示页号，d表示页内偏移
  4. 连续页可分配不连续页框(离散分配)
  5. 每个作业一张页表，保存作业各个页入内存情况
  6. 系统设置两个寄存器保存当前运行进程的页表的起始地址和长度

> 虚地址 -> 实地址
>
> 1. 直接地址映像：查页表(缺：效率50%)
> 2. 相关地址映像：配置8到16个超高速寄存器用于暂存当前运行进程的页表表目。查找时先查寄存器，若找到，直接得到地址；否则，查表并将表目放入寄存器
>
> 页框的分配和回收通过空页框链表。

超高速寄存器的置换策略要符合程序局部性特征。
> 程序局部性特征
> 1.时间局部性：刚被访问的主存单元不久后还会被访问。
> 2.空间局部性：刚被访问的主存单元其邻近单元不久后会被访问。

页表表目扩充：页号、页框号、保护位、有效位。

页面共享：如果页面为纯页(可重入/只读)，则可以共享。

页表结构：层次页表、哈希页表、反置页表。

### 8.3分段存储管理

- 思想：
  1. 物理地址空间按照可变分区分配
  2. 逻辑地址空间分段，从0开始编号
  3. 逻辑地址表示(s, d)段号s，段内偏移d
  4. 每个分段可以离散分配
  5. 每个进程一张段表(段号、起始地址、长度)
  6. 基址和界限寄存器用于保存当前运行进程段表的地址和长度

## 9.虚存管理

> 虚拟内存将用户逻辑内存与物理内存分开。
>
> 逻辑地址 >= 物理地址
>
> 只有一部分程序在内存中。
> 原因：许多情况下，不需要整个程序，例如，处理错误的代码很少使用，数组、链表和表分配超过需要，程序的某些选项或功能很少使用

### 9.1按需分页

页表表目：页号、页框号、访问位、有效位、外存地址、修改位

按需分页：只有在需要时才将页面保存到内存中。好处：需要更少的I/O、需要更少的内存、更快的响应、更多的用户。

懒惰交换：只有在需要页时，才将其调入内存。
> 如果访问不在主存的页面，产生缺页中断，对应的处理是将该页调入内存

性能分析：
$EAT = (1-p) \times ma + p \times 页错误时间$
> EAT(effective access time)：有效访问时间
> ma(memory access)：内存访问时间
> 页错误时间主要包括：处理页错误中断、读入页、重新启动进程。

### 9.2页置换

> 内存过度分配的解决办法之一：页置换

- 页面置换算法：
  1. FIFO页置换：置换掉最旧的页。
     - 存在奇异(当页框更多时，缺页次数更多)，极少数情况。
  2. 最优置换：将不再使用的或最远将来使用才使用的页面置换。
     - 难以实现，可以作为一个标准使用。
  3. LRU(least-recently-used)最近最少使用算法：将最近最少使用的页面作为下一次置换对象。
     - 实现方法：栈(具有头尾指针)、计数器(MRU和LRU)、时钟、若干位表示访问情况。
  4. 近似LRU页置换：附加引用位算法、二次机会算法、增强二次机会算法。
  5. 基于计数的页置换：最不经常使用页置换算法(LFU)、最常使用页置换算法(MFU)。

### 9.3页框分配

有一个最小页框数，原因之一是性能，随着分配给每个进程的页框数量的减少，页错误会增加，从而减慢进程的执行。另外，必须要有足够的页框容纳所有单个指令所引用的页。

- 分配算法：
  1. 固定分配：平均分配、按比例分配。
  2. 按优先级分配

全局置换：允许一个进程从所有页框集合中选择一个置换。
局部置换：要求每个进程仅从自己的分配页框中进行选择。

### 9.4抖动

抖动(Trashing)：频繁的页调度行为。
> 一个进程不停输入输出、刚刚被置换的页又要被访问、系统大量时间用于I/O

通过构建局部模型可以了解进程“需要”多少页框。

工作集模型：工作集是一个进程在某一小段时间内访问页面的集合。利用工作集模型可防止抖动，也可以进行页面置换。

$\Delta$太小，可能无法包含整个局部；$\Delta$太大，可能包含多个局部；$\Delta$无穷，包含整个集合

## 10.文件系统

> **文件系统**：操作系统中负责操纵和管理文件的一整套设施，它实现文件的共享和保护，方便用户“**按名存取**”
>
> **文件**：是记录在外存上的相关信息的具有名称的集合。
>
> 文件属性：名称、标识符、类型、位置、大小、保护、时间、日期和用户标识。
>
> 文件操作：创建文件、写文件、读文件、文件内重定位、删除文件、截短文件、Open(Fi)将该文件目录项内容入内存，建立系统与文件联系、Close(Fi)将相应目录写回外存，删除联系。
>
> 文件结构：无结构、简单结构、复杂结构，由操作系统和程序决定。

### 10.1访问方式

1. 顺序访问
2. 直接访问(随机访问)

### 10.2目录结构

目录、文件名(需要避免冲突)、外存位置

**一级目录**：所有文件包含在同一目录中。
无子目录、存在命名问题。

**二级目录**：每个用户都有自己的用户文件目录，可通过搜索系统的主文件目录找到每个用户文件目录。
缓解了命名冲突，增加了效率，但是没有分组能力。

**树状结构目录**
路径名有两种：绝对路劲名或相对路径名
树状结构禁止共享文件和目录。

**无环图目录**
允许目录含有共享子目录和文件

- 避免环的方法：
  1. 链接只能指向文件，不能是子目录
  2. 添加一个环路检测算法

### 10.3保护

文件的所有者应该决定谁可以做什么。

访问类型：读、写、执行、添加、删除、列表清单。

访问控制列表：给定每个用户名机器所允许的访问类型。

三种用户类型：拥有者、组、其他。

### 10.4文件组织

应用程序->逻辑文件系统->文件组织系统->基本文件系统->I/O控制->设备

### 10.5分配

1.**连续分配**：要求每个文件在磁盘上占有一组连续的块，一个文件的目录包括开始块的地址和该文件所分配区域的长度。
优：简单、可随机访问，缺：长度固定、有碎片

2.**链接分配**：每个文件是磁盘块的链表，目录包括文件第一块的指针和最后一块的指针
优：简单、无碎片，缺：不能随机访问

3.**索引分配**：将所有指针放在索引块中。
优：随机访问、无碎片，缺：有索引块的开销(可以接受)

### 10.5外存空间管理

1.**位示图**：用一个二进制位表示一个块的使用情况(空闲为1，占用为0)
优：占用空间少、可常驻内存、分配和回收的效率高

2.**空白块链**(类似页框分配)：使用链表。
用于离散分配，不支持连续分配。

3.**计数**(类似可变分区分配)：使用起始块号和空白块数。

### 10.6效率和性能

顺序访问通过预先读取和马上释放加以优化
> 马上释放：一旦请求下一页，马上从缓存中删除上一页。
>
> 预先读取：将请求的页和之后的一些页一起读入并缓存。

## 11.磁盘管理

传输速率(transfer rate)：在驱动器和计算机之间的数据传输速率。

定位时间(Positioning time)：由寻道时间(磁头到数据所在磁道所需时间)和旋转延迟(数据所在扇区移动到磁头下的所需时间)。

飞高：磁头和盘片的距离。

磁盘驱动器可以看做一个一维的**逻辑块**的数组，逻辑块是最小的传输单位，一维的逻辑块数组按顺序映射到磁盘扇区。扇区0是最外面注明的第一个磁道的第一个扇区。

### 11.1磁盘调度

> 减少访问时间主要是减少寻道时间
>
> **磁盘带宽**是所传递的总的字节数除以从服务请求开始到最后传递结束时的总时间

1. **FCFS调度**

2. **最短寻道时间优先(shortest-seek-time-first, SSTF)**调度：将离读写头最近的访问作为下一访问对象
   - 缺：存在饥饿，磁滞现象

3. **SCAN**(扫描策略)：磁臂从一端向另一端移动，处理移动过程中遇到的服务请求。
   - 缺：存在访问不均匀
   - 扩展：
     - **C-SCAN**(环路扫描)：磁头从一段移到另一端，随着移动不断地处理请求，不过到达另一端后，它会马上返回到磁盘开始，返回时不处理请求
     - **Look**与**C-Look**：向一个方向移动时会先判断是否有请求。

### 11.2磁盘管理

低级/物理格式化：将磁盘分成扇区以便磁盘控制器能读和写。

扇区的数据结构：头部(扇区号码)、数据、尾部(纠错代码)

纠错代码(error-correcting code, ECC)：当控制器写入一个扇区的数据时，ECC会用一个根据根据磁盘数据计算出来的值更新。当读入一个扇区时，ECC值会从新计算，并与原来存储的值比较。

RAID通过冗余提高数据可靠性。
![RAID级别](image/os/RAID_1.png)
![RAID级别](image/os/RAID_2.png)
> RAID0：按块级别分散的磁盘列阵，无冗余。
> RAID1：1:1镜像
> RAID2：内存方式的差错纠正代码结构，使用基于奇偶位的错误检测。
> RAID3：位交织奇偶结构，可以检测单个扇区是否正确读取。
> RAID4：块交织奇偶结构，将N个磁盘的奇偶存在单个磁盘上。
> RAID5：块交织分布奇偶结构，将N个磁盘的数据和奇偶分布在所有N+1个磁盘上
> RAID6：P+Q冗余方案，类似于RAID5，但是保存了额外的冗余信息放置多个磁盘出错，不使用奇偶校验而是差错纠正码。
> RAID0+1：RAID0提供性能，RAID1提供可靠性

## 12.I/O输入系统

> 总线(bus)：一组线和一组严格定义的可以描述在线上传输信息的协议。
> 控制器(controller)：用于操作端口、、总线或设备的一组电子器件。
> 端口(port)：设备与计算机通信的连接点。

I/O端口通常有4种寄存器：状态寄存器、控制寄存器、数据输入寄存器和数据输出寄存器。

轮询：用于确定设备的状态。

块设备包含磁盘驱动器，命令包括读、写、查找。

字符设备包括键盘、鼠标、串口，命令包括get、put。

系统维护一个设备状态表。

高速缓存：可以保留数据副本的高速存储器。使对数据的访问更加高效。

- **Spooling**(同时外围设备在线操作) 假脱机：将慢速设备改造成可共享的虚设备。
  - 组成：
    1. 两个进程spi，spo;
    2. 磁盘缓冲：输入井和输出井；
    3. 内存缓冲。
